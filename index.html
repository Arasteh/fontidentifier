<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Font Finder Pro | جستجوگر پیشرفته فونت</title>
    <style>
        :root {
            --primary: #4a78ff;
            --bg: #f8f9fa;
            --card: #ffffff;
            --text: #333;
            --border: #edf0f5;
        }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
        }
        .container { max-width: 1100px; margin: 0 auto; }
        .layout { display: grid; grid-template-columns: 1fr 340px; gap: 20px; }
        .card { background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.04); height: fit-content; }
        
        h1 { color: var(--primary); margin-bottom: 25px; text-align: center; font-size: 24px; }
        h3 { margin-top: 0; font-size: 16px; border-bottom: 1px solid var(--border); padding-bottom: 10px; margin-bottom: 15px; }
        
        /* Chips */
        .chip {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px;
            background: #f0f0f0;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        .chip.selected { background: var(--primary); color: white; }
        .chip.history { background: #e8f0ff; color: var(--primary); font-size: 11px; padding: 4px 10px; }
        /* Generic Visual Container */
        .visual-container {
            margin: 20px 0;
            background: #fdfdfd;
            border-radius: 10px;
            border: 1px dashed #ddd;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        /* Ratio Visual (Bars) */
        .ratio-visual {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 30px;
            height: 140px;
            width: 100%;
            position: relative;
            cursor: ns-resize;
            user-select: none;
        }
        .rect {
            width: 40px;
            background: var(--primary);
            border-radius: 4px 4px 0 0;
            position: relative;
            transition: height 0.1s ease;
            pointer-events: none;
        }
        .rect.base { background: #ddd; height: 100%; border-radius: 4px; }
        .rect-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: bold;
            white-space: nowrap;
        }
        /* Contrast Visual (Circles) */
        .contrast-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 50px;
            height: 100px;
            width: 100%;
        }
        .circle-wrapper {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .circle {
            background: var(--primary);
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        .circle.fixed { width: 60px; height: 60px; background: #ddd; }
        .circle.dynamic { width: 60px; height: 60px; }
        /* Slider */
        .slider-box { width: 100%; max-width: 300px; }
        input[type=range] {
            width: 100%;
            cursor: pointer;
        }
        /* Results - Ultra Compact Style */
        .result-item {
            padding: 8px 12px;
            margin-bottom: 6px;
            border-radius: 6px;
            background: #fff;
            border: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .font-link {
            text-decoration: none;
            color: inherit;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-grow: 1;
        }
        .font-link:hover .font-name { color: var(--primary); }
        .weight-name {
            font-size: 10px;
            color: #888;
            background: #f5f5f5;
            padding: 0px 5px;
            border-radius: 3px;
            font-weight: normal !important;
        }
        .match-score {
            font-size: 14px;
            color: var(--primary);
            opacity: 0.8;
            font-weight: bold;
        }
        .controls { display: flex; justify-content: space-between; margin-top: 25px; padding-top: 15px; border-top: 1px solid var(--border); }
        button { padding: 8px 16px; border: none; border-radius: 8px; cursor: pointer; background: #eee; font-family: inherit; font-size: 13px; transition: 0.2s; }
        button#nextBtn { background: var(--primary); color: white; }
        .hidden { display: none; }
        @media(max-width: 900px) { .layout { grid-template-columns: 1fr; } }

        /* حالت تاریک خودکار */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #111111;
                --card: #1e1e1e;
                --text: #e5e5e5;
                --border: #383838;
            }
            .chip {
                background: #2a2a2a;
                color: #c0c0c0;
            }
            .chip.history {
                background: #1f2a44;
                color: var(--primary);
            }
            .visual-container {
                background: #1a1a1a;
                border-color: #4a4a4a;
            }
            .rect.base {
                background: #4a4a4a;
            }
            .circle.fixed {
                background: #555555;
            }
            .result-item {
                background: var(--card);
                border-color: var(--border);
            }
            .weight-name {
                background: #333333;
                color: #aaaaaa;
            }
            button {
                background: #2a2a2a;
                color: #dddddd;
            }
            h3 {
                color: #ccc;
                border-bottom-color: var(--border);
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>جستجوگر فونت</h1>
    <div class="layout">
        <div class="card">
            <div id="historyChips" style="margin-bottom: 15px;"></div>
            <div id="questionContainer">
                <p style="text-align:center; color:#888;">در حال بارگذاری داده‌ها...</p>
            </div>
            <div class="controls">
                <div>
                    <button onclick="prevStep()">قبلی</button>
                    <button id="nextBtn" onclick="nextStep()">نمی‌دانم / بعدی</button>
                </div>
                <button onclick="resetAll()" style="color: #888; background: transparent;">شروع از نو</button>
            </div>
        </div>
        <div class="card">
            <h3>نتایج تطبیق یافته</h3>
            <div id="results"></div>
        </div>
    </div>
</div>
<script>
let database = null;
let featureKeys = [];
let currentStep = 0;
let selectedAnswers = {};
async function init() {
    try {
        const response = await fetch('database.json');
        if (!response.ok) throw new Error('فایل دیتابیس یافت نشد.');
        database = await response.json();
        
        // Ensure contrast feature exists
        if (!database.features.contrast) {
            database.features.contrast = {
                "label_fa": "کنتراست ضخامت",
                "type": "numeric"
            };
        }

        // ترتیب سؤال‌ها بر اساس قدرت تمایز داده‌های واقعی (داینامیک و خودکار با اضافه شدن فونت/ویژگی جدید)
        const originalOrder = Object.keys(database.features);
        featureKeys = [...originalOrder];
        loadFromURL();

        const buildInstances = () => {
            let instances = [];
            database.fonts.forEach(font => {
                const base = font.features || {};
                if (font.weights && typeof font.weights === 'object' && Object.keys(font.weights).length > 0) {
                    Object.keys(font.weights).forEach(wName => {
                        const wFeat = font.weights[wName] || {};
                        const inst = { ...base, ...wFeat };
                        instances.push(inst);
                    });
                } else {
                    instances.push({ ...base });
                }
            });
            return instances;
        };
        const instances = buildInstances();

        const computeDistinction = (key) => {
            const feat = database.features[key];
            if (!feat) return 0;
            const vals = instances.map(i => i[key]).filter(v => v !== undefined && v !== null);
            if (vals.length < 2) return 0;
            let entropy = 0;
            const total = vals.length;
            if (feat.type === "numeric") {
                const minV = Math.min(...vals);
                const maxV = Math.max(...vals);
                if (minV === maxV) return 0;
                const numBins = 10;
                const binCounts = new Array(numBins).fill(0);
                const range = maxV - minV;
                vals.forEach(v => {
                    let bin = Math.floor(((v - minV) / range) * (numBins - 1e-10));
                    bin = Math.max(0, Math.min(numBins - 1, bin));
                    binCounts[bin]++;
                });
                binCounts.forEach(c => {
                    if (c > 0) {
                        const p = c / total;
                        entropy -= p * Math.log2(p);
                    }
                });
            } else {
                const valueCounts = {};
                vals.forEach(v => {
                    let sig;
                    if (Array.isArray(v)) {
                        const uniqueSorted = [...new Set(v.map(String))].sort();
                        sig = JSON.stringify(uniqueSorted);
                    } else {
                        sig = String(v);
                    }
                    valueCounts[sig] = (valueCounts[sig] || 0) + 1;
                });
                Object.values(valueCounts).forEach(c => {
                    if (c > 0) {
                        const p = c / total;
                        entropy -= p * Math.log2(p);
                    }
                });
            }
            return entropy;
        };

        const distinctionMap = {};
        originalOrder.forEach(key => {
            distinctionMap[key] = computeDistinction(key);
        });

        // اعمال ترتیب جدید (بیشترین تمایز اول) بدون تغییر در بارگذاری URL
        featureKeys = [...originalOrder].sort((a, b) => {
            const diff = (distinctionMap[b] || 0) - (distinctionMap[a] || 0);
            if (diff !== 0) return diff;
            return originalOrder.indexOf(a) - originalOrder.indexOf(b);
        });

        renderQuestion();
        updateResults();
    } catch (error) {
        console.error('Error loading database:', error);
        document.getElementById("questionContainer").innerHTML = 
            `<p style="color:red; text-align:center;">خطا در بارگذاری دیتابیس. لطفا فایل database.json را بررسی کنید.</p>`;
    }
}
function updateURL() {
    if (!database) return;
    let compressed = "";
    featureKeys.forEach(key => {
        const val = selectedAnswers[key];
        if (val === undefined) compressed += "x";
        else if (val === null) compressed += "u";
        else if (database.features[key].type === "categorical") compressed += database.features[key].values.indexOf(val);
        else compressed += Math.round(val * 10);
    });
    history.replaceState(null, "", "?f=" + compressed);
}
function loadFromURL() {
    if (!database) return;
    const params = new URLSearchParams(location.search);
    const str = params.get("f");
    if (!str) return;
    featureKeys.forEach((key, i) => {
        const char = str[i];
        if (!char || char === "x") return;
        if (char === "u") { selectedAnswers[key] = null; return; }
        const feat = database.features[key];
        if (feat.type === "categorical") selectedAnswers[key] = feat.values[parseInt(char)];
        else selectedAnswers[key] = parseInt(char) / 10;
    });
}
function renderQuestion() {
    if (!database) return;
    const key = featureKeys[currentStep];
    const feature = database.features[key];
    const container = document.getElementById("questionContainer");
    const nextBtn = document.getElementById("nextBtn");
    
    container.innerHTML = `<h4 style="margin:0 0 15px 0; color:#555;">${feature.label_fa}</h4>`;
    renderHistory();
    const currentVal = selectedAnswers[key];
    
    // Button state management
    if (currentStep === featureKeys.length - 1 && currentVal !== undefined) {
        nextBtn.classList.add("hidden");
    } else if (currentStep >= featureKeys.length - 1 && currentVal === undefined) {
        nextBtn.classList.remove("hidden");
        nextBtn.innerText = "پایان سوالات";
    } else {
        nextBtn.classList.remove("hidden");
        nextBtn.innerText = (currentVal == null) ? "نمی‌دانم / بعدی" : "بعدی";
    }
    if (feature.type === "categorical") {
        const chipContainer = document.createElement("div");
        feature.values.forEach(val => {
            const chip = document.createElement("div");
            chip.className = `chip ${currentVal === val ? 'selected' : ''}`;
            chip.innerText = val;
            chip.onclick = () => { 
                selectedAnswers[key] = val; 
                updateURL(); 
                renderQuestion(); 
                updateResults(); 
            };
            chipContainer.appendChild(chip);
        });
        container.appendChild(chipContainer);
    }
    if (feature.type === "numeric") {
        const val = currentVal ?? 0.5;
        const visualWrap = document.createElement("div");
        visualWrap.className = "visual-container";
        if (key === 'contrast') {
            // Circle Contrast Visual
            visualWrap.innerHTML = `
                <div class="contrast-visual">
                    <div class="circle-wrapper"><div class="circle fixed"></div></div>
                    <div class="circle-wrapper"><div class="circle dynamic" id="dynCircle" style="width:${60 * (1 - val*0.99)}px; height:${60 * (1 - val*0.99)}px"></div></div>
                </div>
                <div class="slider-box">
                    <input type="range" min="0" max="1" step="0.01" value="${val}" id="contrastSlider">
                    <div style="text-align:center; font-size:12px; margin-top:5px; color:#888;">کنتراست: <span id="contrastVal">${Math.round(val*100)}%</span></div>
                </div>
            `;
            
            const slider = visualWrap.querySelector('#contrastSlider');
            slider.addEventListener('input', (e) => {
                const newScore = parseFloat(e.target.value);
                const dynCircle = document.getElementById('dynCircle');
                const scoreLabel = document.getElementById('contrastVal');
                
                // Update circle size (100% size at 0, ~1% size at 1.0)
                const newSize = 60 * (1 - newScore * 0.99);
                dynCircle.style.width = newSize + "px";
                dynCircle.style.height = newSize + "px";
                scoreLabel.innerText = Math.round(newScore * 100) + "%";
                
                selectedAnswers[key] = Math.round(newScore * 10) / 10;
                updateURL();
                updateResults();
                if (nextBtn.innerText.includes("نمی‌دانم")) nextBtn.innerText = "بعدی";
            });
        } else {
            // Bars Ratio Visual
            visualWrap.innerHTML = `
                <div class="ratio-visual" id="barVisual">
                    <div class="rect" id="dragRect" style="height: ${val * 100}%"><span class="rect-label">${Math.round(val*100)}%</span></div>
                    <div class="rect base"><span class="rect-label">۱۰۰٪</span></div>
                </div>
            `;
            
            const visual = visualWrap.querySelector('#barVisual');
            let isDragging = false;
            const handleInteraction = (e) => {
                const rect = visual.getBoundingClientRect();
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                let percent = 1 - ((clientY - rect.top) / rect.height);
                percent = Math.max(0, Math.min(1, percent));
                const roundedVal = Math.round(percent * 10) / 10;
                
                const dragRect = document.getElementById("dragRect");
                if (dragRect) {
                    dragRect.style.height = (roundedVal * 100) + "%";
                    dragRect.querySelector('.rect-label').innerText = Math.round(roundedVal * 100) + "%";
                }
                selectedAnswers[key] = roundedVal;
                updateURL();
                updateResults();
                if (nextBtn.innerText.includes("نمی‌دانم")) nextBtn.innerText = "بعدی";
            };
            visual.addEventListener('mousedown', (e) => { isDragging = true; handleInteraction(e); });
            window.addEventListener('mouseup', () => { isDragging = false; });
            window.addEventListener('mousemove', (e) => { if (isDragging) handleInteraction(e); });
            visual.addEventListener('touchstart', (e) => { isDragging = true; handleInteraction(e); }, {passive: false});
            window.addEventListener('touchend', () => { isDragging = false; });
            window.addEventListener('touchmove', (e) => { if (isDragging) { e.preventDefault(); handleInteraction(e); } }, {passive: false});
        }
        
        container.appendChild(visualWrap);
    }
}
function nextStep() {
    if (currentStep < featureKeys.length - 1) {
        const key = featureKeys[currentStep];
        if (selectedAnswers[key] === undefined) selectedAnswers[key] = null;
        currentStep++;
        renderQuestion();
    } else {
        const key = featureKeys[currentStep];
        if (selectedAnswers[key] === undefined) selectedAnswers[key] = null;
        renderQuestion();
    }
}
function prevStep() {
    if (currentStep > 0) { currentStep--; renderQuestion(); }
}
function renderHistory() {
    if (!database) return;
    const box = document.getElementById("historyChips");
    box.innerHTML = "";
    Object.keys(selectedAnswers).forEach(key => {
        const val = selectedAnswers[key];
        const chip = document.createElement("div");
        chip.className = "chip history";
        chip.innerText = `${database.features[key].label_fa}: ${val === null ? '؟' : val}`;
        chip.onclick = () => { currentStep = featureKeys.indexOf(key); renderQuestion(); };
        box.appendChild(chip);
    });
}
function updateResults() {
    if (!database) return;
    const resBox = document.getElementById("results");
    resBox.innerHTML = "";
    const hasAnyAnswer = Object.values(selectedAnswers).some(v => v !== undefined && v !== null);
    let finalFlatResults = [];
    database.fonts.forEach(font => {
        const calculateScore = (data) => {
            let score = 0;
            let total = 0;
            featureKeys.forEach(key => {
                const userVal = selectedAnswers[key];
                if (userVal == null) return;
                total++;
                let fontVal = data[key] ?? font.features[key];
                if (fontVal === undefined || fontVal === null) {
                    return; // امتیاز صفر برای ویژگی از دست رفته (اصلاح باگ)
                }
                if (Array.isArray(fontVal)) {
                    score += fontVal.includes(userVal) ? 1 : 0;
                } else if (typeof fontVal === 'number') {
                    score += Math.max(0, 1 - Math.abs(fontVal - userVal));
                } else {
                    score += (fontVal === userVal) ? 1 : 0;
                }
            });
            return total > 0 ? (score / total) : 0;
        };
        if (font.weights) {
            Object.keys(font.weights).forEach(wName => {
                const s = hasAnyAnswer ? calculateScore(font.weights[wName]) : 0;
                finalFlatResults.push({ name: font.name, url: font.url, weight: wName, score: s });
            });
        } else {
            const s = hasAnyAnswer ? calculateScore(font.features) : 0;
            finalFlatResults.push({ name: font.name, url: font.url, weight: null, score: s });
        }
    });
    if (!hasAnyAnswer) {
        finalFlatResults = finalFlatResults.sort(() => Math.random() - 0.5).slice(0, 10);
    } else {
        finalFlatResults = finalFlatResults.filter(r => r.score > 0).sort((a, b) => b.score - a.score);
    }
    if (finalFlatResults.length === 0 && hasAnyAnswer) {
        resBox.innerHTML = "<p style='color:#999; text-align:center; font-size:13px;'>نتیجه‌ای یافت نشد.</p>";
        return;
    }
    finalFlatResults.forEach(res => {
        const div = document.createElement("div");
        div.className = "result-item";
        const fontSize = 13 + (res.score * 4);
        const fontWeight = 400 + Math.round(res.score * 500);
        div.innerHTML = `
            <a href="${res.url || '#'}" target="_blank" class="font-link">
                <span class="font-name" style="font-size: ${fontSize}px; font-weight: ${fontWeight};">${res.name}</span>
                ${res.weight ? `<span class="weight-name">${res.weight}</span>` : ''}
            </a>
            ${hasAnyAnswer ? `<span class="match-score">${Math.round(res.score * 100)}%</span>` : ''}
        `;
        resBox.appendChild(div);
    });
}
function resetAll() {
    selectedAnswers = {};
    currentStep = 0;
    history.replaceState(null, "", window.location.pathname);
    renderQuestion();
    updateResults();
}
init();
</script>
</body>
</html>